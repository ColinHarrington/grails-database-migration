<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>4 General Usage</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="4 General Usage">4 General Usage</a></h1>After creating the initial changelog, the typical workflow will be along the lines of:
<ul class="star">
<li>make domain class changes that affect the schema</li>
<li>add changes to the changelog for them</li>
<li>backup your database in case something goes wrong</li>
<li>run <code>grails dbm-update</code> to update your development environment (or wherever you're applying the changes)</li>
<li>check the updated domain class(es) and changelog(s) into source control</li>
</ul><p class="paragraph"/><blockquote class="warning">
When running migration scripts on non-development databases, it's important that you backup the database before running the migration in case anything goes wrong. You could also make a copy of the database and run the script against that, and if there's a problem the real database will be unaffected.
</blockquote><p class="paragraph"/>To create the changelog additions, you can either manually create the changes or with the <a href="../ref/Diff Scripts/dbm-gorm-diff.html" class="Diff Scripts">dbm-gorm-diff</a> script (you can also use the <a href="../ref/Diff Scripts/dbm-diff.html" class="Diff Scripts">dbm-diff</a> script but it's far less convenient and requires a 2nd temporary database).<p class="paragraph"/>You have a few options with <code>dbm-gorm-diff</code>:
<ul class="star">
<li><code>dbm-gorm-diff</code> will dump to the console if no filename is specified, so you can copy/paste from there</li>
<li>if you include the <code>--add</code> parameter when running the script with a filename it will register an include for the the filename in the main changelog for you</li>
</ul><p class="paragraph"/>Regardless of which approach you use, be sure to inspect generated changes and adjust as necessary.<p class="paragraph"/><h4>Autorun on start</h4><p class="paragraph"/>Since Liquibase maintains a record of changes that have been applied, you can avoid manually updating the database by taking advantage of the plugin's auto-run feature. By default this is disabled, but you can enable it by adding<p class="paragraph"/><div class="code"><pre>grails.plugin.databasemigration.updateOnStart = <span class="java&#45;keyword">true</span></pre></div><p class="paragraph"/>to Config.groovy. In addition you must specify the file(s) containing changes; specify the name(s) using the <code>updateOnStartFileNames</code> property, e.g.:<p class="paragraph"/><div class="code"><pre>grails.plugin.databasemigration.updateOnStartFileNames = &#91;'changelog.groovy'&#93;</pre></div><p class="paragraph"/>Since changelogs can contain changelogs you'll most often just specify the root changelog, changelog.groovy by convention. Any changes that haven't been executed (in the specified file(s) or files included by them) will be run in the order specified.<p class="paragraph"/>
    
<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-16219500-1']);
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
</script>
</body>
</html>
